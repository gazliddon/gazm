;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

task    
task.next        equ 0
task.func        equ 2
task.tick        equ 4
task.sleep       equ 6
task.d           equ 8
task.y           equ 10
task.x           equ 12
task.temp0       equ 14
task.temp1       equ 16
task.size        equ 18

num_of_tasks    equ 100

task_buffer_size equ task.size*num_of_tasks

tasks           zmb task_buffer_size
tasks_end

active_tasks    zmd 1
free_tasks      zmd 1
current_task    zmd 2

task_init_system
    ;; no active tasks
    ;; x is my zero
    ldx #0
    stx active_tasks
    stx current_task

    ldu #tasks
    stu free_tasks
loop_init
    ;; get ptr to next task
    leay task.size,u
    cmpy #tasks_end
    bne no_task
    tfr y,x
    ;;
no_task
    ;; Store set z flags
    ;; if x was zero then we're the end of the list
    sty ,u
    bne loop_init
    rts


;; U -> current task
task_exec 
    lda task.tick,u
    beq @run_task
    dec task.tick,u
    rts
    ;;
@run_task
    lda task.sleep,u
    sta task.tick,u


    ldd task.d,u
    ldx task.x,u
    ldy task.y,u
    
    jsr [task.func,u]

    leau tsk_size,u 
    pshu d,x,y
    leau -tsk_size+6,y

    rts

task_run_tasks
    ;; u -> active task list
    ldu  #active_tasks
run_loop ;; u -> next task, if zero end of list
    ldu ,u
    beq run_done ;; set this as the current task
    stu current_task
    ;; run the task
    bsr task_exec
    ;; do the next one
    bra run_loop
run_done
    rts


;; Allocates a task, will be executed after the current
;; task
;; X -> func
;; A = time till execute
;; U -> current task
;; preserves u
;; y -> new task
task_alloc
    ;; y -> free task
    ldy     free_tasks
    bne     @got_task
    ;;
    ;; no tasks!
    swi2
    ;; func, tick, sleep for new task
@got_task
    stx task.func,y
    sta task.tick,y
    clr task.sleep,y

    ;; Get next free task
    ldd ,y
    ;; free tasks now -> to that
    std free_tasks

    ;; insert myself into linked list
    ;; will execute after current task
    ldx ,u
    stx ,y
    sty ,u

    rts

;; x -> task to free
task_free
    rts
